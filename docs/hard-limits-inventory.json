[
  {
    "id": "api.scheduler.min_interval_minutes",
    "component": "workers/api",
    "category": "scheduler",
    "scope": "daily collection cadence",
    "current_value": 0,
    "unit": "minutes",
    "risk_class": "continuation_throttle",
    "replacement_behavior": "Hourly cron keeps attempting the current Melbourne collection date until lender-dataset completion is achieved.",
    "rationale": "Forward completeness must not depend on a 24-hour cooldown gate.",
    "source_file": "workers/api/src/constants.ts"
  },
  {
    "id": "api.queue.consumer.max_batch_size",
    "component": "workers/api",
    "category": "queue",
    "scope": "queue consumer batch",
    "current_value": 50,
    "unit": "messages",
    "risk_class": "continuation_throttle",
    "replacement_behavior": "Continue processing remaining tasks in later queue batches without dropping scope.",
    "rationale": "Operational batch sizing is acceptable when the backlog is retained and retried.",
    "source_file": "workers/api/wrangler.toml"
  },
  {
    "id": "api.queue.max_attempts_default",
    "component": "workers/api",
    "category": "queue",
    "scope": "retry policy",
    "current_value": 3,
    "unit": "attempts",
    "risk_class": "continuation_throttle",
    "replacement_behavior": "Failures are recorded, retried with backoff, and surfaced in run/fetch diagnostics instead of disappearing silently.",
    "rationale": "Retries may be bounded if failures remain observable and re-runnable.",
    "source_file": "workers/api/src/constants.ts"
  },
  {
    "id": "api.queue.retry_backoff_seconds_cap",
    "component": "workers/api",
    "category": "queue",
    "scope": "retry pacing",
    "current_value": 900,
    "unit": "seconds",
    "risk_class": "continuation_throttle",
    "replacement_behavior": "Backoff delays retries but never truncates the task graph.",
    "rationale": "Pacing is safe when retries remain durable.",
    "source_file": "workers/api/src/queue/consumer.ts"
  },
  {
    "id": "api.ingest.max_products_per_lender_clamp",
    "component": "workers/api",
    "category": "ingest",
    "scope": "CDR product discovery",
    "current_value": "legacy_only 100..50000",
    "unit": "products",
    "risk_class": "lossy_forbidden",
    "replacement_behavior": "CDR index/detail tasks must enumerate all discovered products; any operational throttle must resume with continuation state rather than slice product ids.",
    "rationale": "Product-level truncation directly violates the project goal.",
    "source_file": "workers/api/src/queue/consumer.ts"
  },
  {
    "id": "api.ingest.cdr_page_limit_runtime",
    "component": "workers/api",
    "category": "ingest",
    "scope": "CDR index pagination",
    "current_value": "runtime continuation up to Number.MAX_SAFE_INTEGER",
    "unit": "pages",
    "risk_class": "continuation_throttle",
    "replacement_behavior": "Paginate until exhaustion or runtime budget, then resume from saved continuation state.",
    "rationale": "Page limits are only acceptable when no pages are omitted.",
    "source_file": "workers/api/src/queue/consumer.ts"
  },
  {
    "id": "api.ingest.seed_fallback_count",
    "component": "workers/api",
    "category": "ingest",
    "scope": "HTML fallback seeds",
    "current_value": 2,
    "unit": "urls",
    "risk_class": "lossy_forbidden",
    "replacement_behavior": "Fallback collection should keep seed discovery/history separately and expand or continue rather than stop at a fixed seed count when CDR is unavailable.",
    "rationale": "Fallback coverage should not be silently constrained by a tiny seed list.",
    "source_file": "workers/api/src/queue/consumer.ts"
  },
  {
    "id": "api.backfill.snapshots_per_month_clamp",
    "component": "workers/api",
    "category": "historical",
    "scope": "Wayback month coverage",
    "current_value": "1..3",
    "unit": "snapshots",
    "risk_class": "lossy_forbidden",
    "replacement_behavior": "Historical collection should queue continuation work until all useful monthly snapshots are explored.",
    "rationale": "Month-level snapshot caps can omit legitimate historical evidence.",
    "source_file": "workers/api/src/pipeline/bootstrap-jobs.ts"
  },
  {
    "id": "api.public.historical_max_days",
    "component": "workers/api",
    "category": "historical",
    "scope": "public manual historical pull request",
    "current_value": 30,
    "unit": "days",
    "risk_class": "abuse_guardrail",
    "replacement_behavior": "Large public requests should use async job orchestration rather than fail open-ended synchronous requests.",
    "rationale": "User-triggered range limits are acceptable when broader async paths exist.",
    "source_file": "workers/api/wrangler.toml"
  },
  {
    "id": "api.validation.home_rate_percent",
    "component": "workers/api",
    "category": "validation",
    "scope": "home-loan normalization",
    "current_value": "0..100",
    "unit": "%",
    "risk_class": "continuation_throttle",
    "replacement_behavior": "Store broad structurally plausible values, classify anomalies separately, and let trusted views apply narrower consumer filters.",
    "rationale": "Write-time validation should avoid dropping unusual but parseable rows.",
    "source_file": "workers/api/src/ingest/normalize.ts"
  },
  {
    "id": "api.validation.home_comparison_rate_percent",
    "component": "workers/api",
    "category": "validation",
    "scope": "home-loan normalization",
    "current_value": "0..100",
    "unit": "%",
    "risk_class": "continuation_throttle",
    "replacement_behavior": "Outlier comparison rates are retained for later analyst review unless structurally invalid.",
    "rationale": "Historical truth is more important than enforcing consumer-safe display ranges at ingest time.",
    "source_file": "workers/api/src/ingest/normalize.ts"
  },
  {
    "id": "api.validation.annual_fee",
    "component": "workers/api",
    "category": "validation",
    "scope": "home-loan normalization",
    "current_value": "0..1000000",
    "unit": "AUD",
    "risk_class": "continuation_throttle",
    "replacement_behavior": "Very large fees remain ingestible and can be filtered in trusted views.",
    "rationale": "Outlier fee values should not be silently discarded.",
    "source_file": "workers/api/src/ingest/normalize.ts"
  },
  {
    "id": "api.validation.savings_td_rate_percent",
    "component": "workers/api",
    "category": "validation",
    "scope": "savings and term-deposit normalization",
    "current_value": "0..100",
    "unit": "%",
    "risk_class": "continuation_throttle",
    "replacement_behavior": "Broad rates are stored; consumer routes can still default to trusted ranges.",
    "rationale": "Write-time rejection of unusual savings/TD rates is lossy.",
    "source_file": "workers/api/src/ingest/normalize-savings.ts"
  },
  {
    "id": "api.validation.td_term_months",
    "component": "workers/api",
    "category": "validation",
    "scope": "term-deposit normalization",
    "current_value": "1..1200",
    "unit": "months",
    "risk_class": "continuation_throttle",
    "replacement_behavior": "Only structurally impossible term lengths are rejected; long durations remain ingestible.",
    "rationale": "The old 120-month cap could omit legitimate long-maturity products.",
    "source_file": "workers/api/src/ingest/normalize-savings.ts"
  },
  {
    "id": "api.validation.collection_date",
    "component": "workers/api",
    "category": "validation",
    "scope": "all ingest rows",
    "current_value": "1990-01-01..today+1d",
    "unit": "date",
    "risk_class": "continuation_throttle",
    "replacement_behavior": "Invalid dates are still hard rejects because they break longitudinal indexing.",
    "rationale": "This is a structural integrity guardrail, not a quality clamp.",
    "source_file": "workers/api/src/ingest/validate-common.ts"
  },
  {
    "id": "api.query.page_size_max",
    "component": "workers/api",
    "category": "query",
    "scope": "paginated list endpoints",
    "current_value": 1000,
    "unit": "rows per page",
    "risk_class": "continuation_throttle",
    "replacement_behavior": "Clients page through all results instead of relying on a single oversized response.",
    "rationale": "Per-page sizing is safe when the next page remains accessible.",
    "source_file": "workers/api/src/db/queries.ts"
  },
  {
    "id": "api.query.latest_limit_max",
    "component": "workers/api",
    "category": "query",
    "scope": "latest endpoints",
    "current_value": 1000,
    "unit": "rows",
    "risk_class": "abuse_guardrail",
    "replacement_behavior": "Analyst exports and paginated list endpoints provide full retrieval when current latest views exceed synchronous caps.",
    "rationale": "Synchronous latest lists can stay bounded if full retrieval exists elsewhere.",
    "source_file": "workers/api/src/db/queries.ts"
  },
  {
    "id": "api.query.timeseries_page_size",
    "component": "workers/api",
    "category": "query",
    "scope": "timeseries endpoints",
    "current_value": 1000,
    "unit": "rows per page",
    "risk_class": "continuation_throttle",
    "replacement_behavior": "Use cursor pagination to traverse the full series without truncation.",
    "rationale": "Timeseries access is non-lossy as long as cursors continue the series.",
    "source_file": "workers/api/src/routes/public.ts"
  },
  {
    "id": "api.query.export_max_rows_sync",
    "component": "workers/api",
    "category": "query",
    "scope": "legacy synchronous export endpoints",
    "current_value": 10000,
    "unit": "rows",
    "risk_class": "abuse_guardrail",
    "replacement_behavior": "Use `POST /exports` plus artifact download routes for complete public exports.",
    "rationale": "Legacy sync exports remain for compatibility, but full retrieval must use async export jobs.",
    "source_file": "workers/api/src/db/queries.ts"
  },
  {
    "id": "api.admin.db_rows_limit",
    "component": "workers/api",
    "category": "admin",
    "scope": "admin diagnostics table previews",
    "current_value": "1..500",
    "unit": "rows",
    "risk_class": "abuse_guardrail",
    "replacement_behavior": "Admin previews stay bounded; deep retrieval should use targeted queries or exports.",
    "rationale": "Operational admin pages do not need unbounded synchronous dumps.",
    "source_file": "workers/api/src/routes/admin-db.ts"
  },
  {
    "id": "api.logs.query_limit_max",
    "component": "workers/api",
    "category": "logging",
    "scope": "system log downloads",
    "current_value": 10000,
    "unit": "rows",
    "risk_class": "abuse_guardrail",
    "replacement_behavior": "Bound synchronous log pulls and rely on repeated paging or download-specific tooling for deeper audits.",
    "rationale": "Log browsing is operational, not part of the canonical rate history.",
    "source_file": "workers/api/src/utils/logger.ts"
  },
  {
    "id": "site.pivot.page_fetch_size",
    "component": "site",
    "category": "frontend",
    "scope": "pivot data loading",
    "current_value": 1000,
    "unit": "rows per API page",
    "risk_class": "continuation_throttle",
    "replacement_behavior": "The browser fetches all pages sequentially instead of stopping at 10,000 rows.",
    "rationale": "Frontend convenience must not cap analyst retrieval scope.",
    "source_file": "site/ar-pivot.js"
  },
  {
    "id": "site.chart.max_points",
    "component": "site",
    "category": "frontend",
    "scope": "interactive chart rendering",
    "current_value": 1000,
    "unit": "points rendered",
    "risk_class": "ui_guardrail",
    "replacement_behavior": "Fetch the full filtered dataset, render a sampled chart when dense, and direct users to full export artifacts for complete retrieval.",
    "rationale": "UI responsiveness is a valid constraint only if the full dataset remains retrievable.",
    "source_file": "site/ar-charts.js"
  },
  {
    "id": "site.client_log.queue_max",
    "component": "site",
    "category": "frontend",
    "scope": "browser log buffer",
    "current_value": 500,
    "unit": "entries",
    "risk_class": "ui_guardrail",
    "replacement_behavior": "Old client logs may roll off locally, but canonical server-side diagnostics remain durable.",
    "rationale": "Frontend log buffers are convenience features, not source-of-truth archives.",
    "source_file": "site/ar-utils.js"
  },
  {
    "id": "archive.discovery.fetch_timeout_ms",
    "component": "workers/archive",
    "category": "discovery",
    "scope": "register fetch attempt",
    "current_value": 20000,
    "unit": "ms",
    "risk_class": "continuation_throttle",
    "replacement_behavior": "Retries and subsequent scheduled runs preserve discovery continuity when a single attempt times out.",
    "rationale": "Timeouts are acceptable if failed attempts remain observable and retryable.",
    "source_file": "workers/archive/src/discovery.ts"
  },
  {
    "id": "archive.discovery.max_retries_per_url",
    "component": "workers/archive",
    "category": "discovery",
    "scope": "register fetch retry policy",
    "current_value": 3,
    "unit": "attempts",
    "risk_class": "continuation_throttle",
    "replacement_behavior": "Each failed attempt should be recorded in append-only discovery history and retried later if still unresolved.",
    "rationale": "Retry counts are fine when they do not erase failure evidence.",
    "source_file": "workers/archive/src/discovery.ts"
  },
  {
    "id": "archive.discovery.failure_payload_max_chars",
    "component": "workers/archive",
    "category": "discovery",
    "scope": "failure payload storage",
    "current_value": 50000,
    "unit": "chars",
    "risk_class": "lossy_forbidden",
    "replacement_behavior": "Persist full failure payloads to object storage and only truncate UI previews if needed.",
    "rationale": "Truncated failure bodies can hide the exact cause of discovery regressions.",
    "source_file": "workers/archive/src/discovery.ts"
  },
  {
    "id": "archive.admin.endpoints_limit_max",
    "component": "workers/archive",
    "category": "admin",
    "scope": "archive admin endpoint list",
    "current_value": 1000,
    "unit": "rows",
    "risk_class": "abuse_guardrail",
    "replacement_behavior": "Use paging or targeted filters for large admin result sets.",
    "rationale": "Operational admin screens can stay bounded.",
    "source_file": "workers/archive/src/index.ts"
  }
]
